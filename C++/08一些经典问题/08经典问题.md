<!--
 * @Author: your name
 * @Date: 2021-10-08 16:44:34
 * @LastEditTime: 2021-10-08 17:25:14
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /WorkSpace/C++/08一些经典问题/08经典问题.md
-->
# 经典问题

## 关于const的疑问

### const常量的判别准则

- 只有用字面量初始化的const常量才会进入符号表
- 使用其他变量初始化的const常量仍然是只读变量
- 被volatile修饰的const常量不会进入符号表

> 在编译期间不能直接确定初始值的const标识符，都被作为只读变量处理

### const引用类型与初始化变量

- 相同：初始化变量成为只读变量
- 不同：生成一个新的只读变量

## 关于引用的疑问

- 指针是一个变量
  - 值为一个地址，不需要初始化，可以保存不同的地址
  - 通过指针可以访问对应内存地址中的值
  - 指针可以被const修饰成为常量或者只读变量
- 引用只是一个变量的新名字
  - 对引用的操作（赋值，取地址等）都会传递到代表的变量上
  - const引用使其代表的变量具有只读属性
  - 引用必须在定义时初始化，之后无法代表其变量

> 从使用C++语言角度来看
>> 引用与指针没有任何关系
>> 引用是变量的新名字，操作引用就是操作对应变量
>
> 从C++编译器角度来看
>> 为了支持新概念“引用”必须要一个有效的解决方案
>> 在编译器内部，使用指针常量来实现"引用"
>> 因此“引用”在定义时必须初始化

### 小结

- 指针是一个变量
- 引用是一个变量的新名字
- const引用能够生成新的只读变量
- 在编译器内部使用指针常量实现“引用”
- 编译器不能直接确定初始值的const标识符都是只读变量


